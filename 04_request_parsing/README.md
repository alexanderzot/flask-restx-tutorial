# Flask-RESTX tutorial

**Оглавление:**

1. [Установка Flask-RESTX в виртуальную среду](../01_virtual_environment/README.md)
2. [Первое приложение](../02_first_application/README.md)
3. [Создание и добавление ресурсов](../03_creating_resources/README.md)
4. Парсинг данных запроса
5. [Маршалинг и форматирование выходных данных](../05_marshalling/README.md)
6. [Объектно-реляционное отображение (ORM)](../06_orm/README.md)

---

## 4. Парсинг данных запроса

При создании обработчиков запросов возникает необходимость получить (распарсить) данные, находящиеся во входящем запросе `request`:
* данные из тела запроса (body);
* данные о заголовках (headers);
* данные формы (form data);
* данные из строк запроса (query string).

> Примечание: запрос `request` доступен по-умолчанию во всех обработчиках запросов (`get`, `post`, ...), хотя и не передается в них качестве аргумента, также его можно импортировать из пакета `flask_restx` и использовать явно, если появится такая необходимость. 

Для таких целей используется инструмент парсинга запросов `reqparse`, доступный в составе пакета `flask-restx`.

```python
from flask_restx import reqparse

user_parser = reqparse.RequestParser()
user_parser.add_argument("name", 
                    type=str, 
                    required=True, 
                    location="json", 
                    help="User name")
user_parser.add_argument("age", 
                    type=int, 
                    default=18, 
                    location="json", 
                    help="User age")
```

Для создания парсера необходимо создать экземпляр класса `RequestParser`, а затем добавить необходимые поля для парсинга данных с помощью вызовов метода `add_argument` для созданного объекта.

Аргументы конструктора `RequestParser()`:
* bundle_errors — если установлено в значение True, то после обнаружения первой ошибки не останавливает разбор аргументом, поэтому возвращает все возникшие ошибки.
* trim — если установлено true, то обрезает окаймляющие пробелы у всех аргументов.

Аргументы метода `add_argument()`:
* name — входное имя поля.
* default — значение по-умолчанию, если аргумент отсутствует при разборе.
* dest — выходное имя поля.
* required — если установлено True, то аргумент является обязательным, если он не будет найден, то вызовется автоматически функция `abort` (по-умолчанию: False).
* type — тип аргумента, поддерживаемые значения: 
  * bool — логическое;
  * int — целое;
  * str — строка;
  * float — дробное число; 
  * [flask_restx.inputs](https://flask-restx.readthedocs.io/en/latest/api.html#module-flask_restx.inputs) — содержит расширенный набор типов, который необходимо импортировать отдельно (`from flask_restx.inputs import <type_name>`):
    * URL — адрес URL (настраиваемый тип);
    * url — настроенный адрес (http, https, ftp, ftps);
    * email — электронная почта (настраиваемый тип);
    * boolean — логическое ("true", "1", "on", True, "false", "0", False);
    * date — дата в формате YYYY-mm-dd: `2012-01-01`;
    * date_from_iso8601 — дата в формате iso8601: `2012-01-01`;
    * datetime_from_rfc822 — дата и время в формате rfc822: `Wed, 02 Oct 2002 08:00:00 EST`;
    * datetime_from_iso8601 — дата и время в формате iso8601: `2012-01-01T23:30:00+02:00`;
    * iso8601interval — интервал дат в соответствии со стандартом iso8601: `2013-01-01T06:00/2013-01-01T12:00`;
    * ipv4 — IPv4 адрес;
    * ipv6 — IPv6 адрес;
    * ip — ip адрес (IPv4 или IPv6);
    * natural — натуральные числа (0, 1, 2, ...);
    * positive — положительные числа (1, 2, 3, ...);
    * regex — регулярное выражение (настраиваемый тип);
    * int_range — диапазон целых чисел со включенными концами (настраиваемый тип).
  * [werkzeug.datastructures.FileStorage](https://werkzeug.palletsprojects.com/en/2.0.x/datastructures/#others) — данные являются файлом, требуется импортировать тип отдельно.
* location — список мест для поиска аргумента, поддерживаемые значения: 
  * json — тело с данными JSON;
  * args — данные из строки запроса (query string);
  * files — данные загруженного файла;
  * form — данные из формы;
  * headers — данные из заголовка HTTP;
  * values — данные из формы или строки запроса;
  * *cookies — данные из куки (не должно работать, но в коде фреймворка есть опечатка, поэтому пока работает)*.
* help — краткое описание аргумента, выводится в случае ошибки обработки данного аргумента.
* action — способ обработки аргумента: 
  * store — сохраняет последнее найденное значение (по-умолчанию);
  * append — объединять значения для одинаковых имен аргумента в список;
  * split — данные аргумента приведены в виде значений с разделителем в виде запятой, сохраняет значения в виде массива аргументов.
* ignore — если установлено True, то игнорирует поля у которых не удалось преобразовать тип, поэтому в сообщении об ошибке не будет содержаться информации о неудавшемся преобразовании типа (по-умолчанию: False).
* trim — если установлено True, то обрезает окаймляющие пробелы вокруг аргумента (по-умолчанию: False).
* choices — перечисляются возможные варианты значений аргумента, задается с помощью списка или кортежа.
* store_missing — если установлено True, то устанавливает значение аргумента по-умолчанию, если аргумент отсутствовал в запросе (по-умолчанию: True).
* nullable — если установлено True, то разрешает null-значение в качестве аргумента (по-умолчанию: True).
* case_sensitive — если установлено True, то регистр данных не изменяется, иначе значения переводятся в нижний регистр (по-умолчанию: True).


Так как `reqparser` имеет внутри себя доступ к данным запроса `request`, то для получения значений и применения заданных свойств достаточно вызвать без параметров метод `parse_args` внутри обработчика запроса:

```python
class Users(Resource):
    def post(self):
        args = user_parser.parse_args()
        return {}
```

У метода `parse_args` есть параметр `strict`, если он установлен в значение True, то выполнение метода завершится с ошибкой, если содержатся поля, которые не были описаны в парсере (ошибка возникает при наличии "лишних" полей). По-умолчанию установлено в значение False. 

Для указания запускаемого парсера используется декоратор `@api.expect` перед методом в котором его необходимо использовать, декоратор также позволяет автоматически заполнять документацию `Swagger`:

```python
@api.route("/users")
class Users(Resource):
    @api.expect(user_parser, validate=True)
    def get(self, book_id):
        return {}
```

Декоратору передается в качестве первого аргумента подготовленный экземпляр класса `RequestParser`. Параметр `validate` позволяет включить валидацию данных запроса, по-умолчанию такая опция выключена.

---

Пример кода к данному параграфу доступен [тут](./main.py).
