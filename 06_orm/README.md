# Flask-RESTX tutorial

**Оглавление:**

1. [Установка Flask-RESTX в виртуальную среду](../01_virtual_environment/README.md)
2. [Первое приложение](../02_first_application/README.md)
3. [Создание и добавление ресурсов](../03_creating_resources/README.md)
4. [Парсинг данных запроса](../04_request_parsing/README.md)
5. [Маршалинг и форматирование выходных данных](../05_marshalling/README.md)
6. Объектно-реляционное отображение (ORM)

---

## 6. Объектно-реляционное отображение (ORM)

Для использования [ORM](https://ru.bmstu.wiki/ORM_(Object-Relational_Mapping)#:~:text=ORM%20(Object%2DRelational%20Mapping)%20%E2%80%93%20%D1%82%D0%B5%D1%85%D0%BD%D0%BE%D0%BB%D0%BE%D0%B3%D0%B8%D1%8F%20%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F%2C%20%D0%BA%D0%BE%D1%82%D0%BE%D1%80%D0%B0%D1%8F,%D0%B8%20%D1%81%D0%B2%D0%BE%D0%B1%D0%BE%D0%B4%D0%BD%D1%8B%D0%B5%20%D1%80%D0%B5%D0%B0%D0%BB%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D0%B8%20%D1%8D%D1%82%D0%BE%D0%B9%20%D1%82%D0%B5%D1%85%D0%BD%D0%BE%D0%BB%D0%BE%D0%B3%D0%B8%D0%B8.)
во фреймворке Flask можно использовать пакет расширения
`Flask-SQLAlchemy`, для установки необходимо выполнить
в виртуальной среде следующую команду:

```bash
pip install flask-sqlalchemy
```

Перед подключением расширения необходимо задать строку 
подключения к базе данных, а также задать параметр 
отслеживание:
```python
app.config["SQLALCHEMY_DATABASE_URI"] = "sqlite:///:memory:"
app.config["SQLALCHEMY_TRACK_MODIFICATIONS"] = True
db = SQLAlchemy(app)
```

Список поддерживаемых баз данных и строк подключений к
ним приветен в [документации](https://docs.sqlalchemy.org/en/14/core/engines.html).
Строка подключения содержит всю необходимую для 
подключения информацию: 
 * название БД;
 * название используемого для подключения драйвера;
 * адрес и порт БД;
 * логин и пароль для доступа к БД;
 * другие данные.

> Примечание: с приведенной строке подключение фигурирует
> подстрока `:memory:`, которая означает, что база
> данных sqlite будет сохранять данные в оперативной 
> памяти, после остановки программы данные все удалятся,
> такое поведение полезно при запуске тестов.

После настройки фреймворка необходимо описать саму 
модель данных, для этого нам потребуется созданный
выше экземпляр класса `SQLAlchemy` — `db`:

```python
class TestData(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    text = db.Column(db.String(80), nullable=False)
```

Для описания новой модели — создается новый класс, который
наследуется от класса `db.Model`, в самом классе описываем
поля с помощью вызовов метода `db.Column()`, в качестве
аргументов ему необходимо передать тип поля и другие ключи.

Общие типы:
 * BigInteger — большое целое число;
 * **Boolean** — логический тип данных;
 * Date — дата;
 * **DateTime** — дата и время;
 * Enum — универсальный тип перечисления;
 * **Float** — число с плавающей точкой;
 * **Integer** — целое;
 * Interval — временной интервал;
 * **LargeBinary** — большие двоичные байтовые данные;
 * Numeric — число с фиксированной точностью;
 * PickleType — сериализованный с помощью pickle 
   объект Python;
 * SmallInteger — маленькое целое; 
 * **String** — строка;
 * **Text** — строка переменного размера;
 * Time — время;
 * Unicode — строка в формате Юникод;
 * UnicodeText — строка переменного размера в формате Юникода;
 * И другие типы.

> Примечание: в списке выше отмечены наиболее 
> используемые при разработке типы.


Подробнее про типы можно прочитать в [документации](https://docs.sqlalchemy.org/en/14/core/type_basics.html).

Параметры полей (столбцов БД):
 * primary_key — если True, то поле 
   является [первичным ключем](http://informatic.ugatu.ac.ru/lib/office/Proekt.htm) 
   (по-умолчанию False);
 * unique — если True, то значение поля для каждой записи 
   должно быть уникальным (по-умолчанию False); 
 * nullable — если True, то значение поля может 
   содержать NULL значение (по-умолчанию True, если 
   только поле не является первичным ключем);
 * default — значение поля по-умолчанию;
 * autoincrement — если True, то будет производиться
   автоматический инкремент значения;
 * index — если True, то для поля будет создан 
   [индекс](https://im-cloud.ru/blog/chto-takoe-indeksy-bazy-dannyh-dlja-nachinajushhih/).

После добавление новой модели, изменения старой или 
смены БД необходимо проинициализировать таблицы с 
помощью вызова метода `create_all()`:
```python
db.create_all()
```

Для создания экземпляра созданной модели необходимо
вызвать ее конструктор и передать в него именованные
аргументы, название которых соответствует названиям
полей модели, при это передавать можно не все поля , 
а только требуемые:

```python
data_1 = TextData(text="This first data")
data_2 = TextData(text="Second data")
```

> Примечание: можно вывести с помощью функции `print`
> созданные объекты (`data_1` и `data_1`), но вывод 
> может содержать не всю интересующую информацию, чтобы 
> задать свой формат вывода — необходимо в 
> классе `TestData` определить метод `__repr__(self)` 
> или `__str__(self)`, которые должен возвращать строку 
> с интересующими данными вывода.

После создания — данные еще не сохраняются в базу данных,
для этого необходимо произвести вызов дополнительных
методов:
```python
db.session.add(data_1)
db.session.add(data_2)
db.session.commit()
```

Для получения всех данных из БД о коллекции какой-то
модели — необходимо вызвать следующий метод:
```python
data_list = TextData.query.all()
```

Для получения списка отфильтрованного по какому-то 
полю — необходимо вызвать метод `filter_by` передав
в качестве аргумента имя поля по которому мы отбираем
значения из БД, а в качестве значения этого аргумента
указываем какие именно значения мы отбираем из БД.

В следующем примере находим все объекты `TextData`, которые
сохранены в базу данных с id равным 1:
```python
data_list = TextData.query.filter_by(id=1)
```

Для получения только первого элемента найденной 
коллекции необходимо вызвать дополнительно метод
`first()`:
```python
data = TextData.query.filter_by(id=1).first()
```

> Примечание: есть также метод `first_or_404`, который
> повторяет поведение `first`, но данных нет, то
> вызывает `abort` с 404 статус кодом.

В примерах выше указаны способы получения данных 
по любому полю и его значению, для задачи получения 
объекта по его идентификатору используется другой метод,
который сразу возвращает единственный экземпляр:
```python
data = TextData.query.get(1)
```

> Примечание: метод `get` работает быстрее, чем 
> `filter_by` с указанием id. 

Послу получения объекта — его данные можно обновлять,
после изменений данных необходимо обновить данные и в БД:
```python
# Get data with id = 1
data = TextData.query.get(1)

# Edit text
data.text = "New text data"

# Update in DB
db.session.commit()
```

### Связь один ко многим

Пример реализации связи один ко многим приведен 
[тут](https://flask-sqlalchemy.palletsprojects.com/en/2.x/quickstart/#simple-relationships).

---

Пример кода к данному параграфу доступен [тут](./main.py).

Для первичной инициализации БД перед 
запуском [main.py](./main.py), необходимо запустить 
скрипт [create_database.py](./create_database.py).
